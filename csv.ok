# /* vim: set filetype=awk ts=2 sw=2 sts=2  : */
BEGIN {
	OK.tips.author  = "'Tim Menzies'"
  OK.tips.email   = "tim@menzies__us"
  OK.tips.version = "0.1"
  OK.tips.license = "'opensource__org/licenses/BSD-3-Clause"
  OK.tips.more    = "ok2awk__github__io/src/csv"
}
"""

## About Csv

"""

@include "ok"

function Row(i) {
	i.id = id()
	has(i,  "raw")
	has(i,  "cooked")
	i.cdoms=0
}
function Range(i) {
	i.lo =  1e32
	i.hi = -1e32
}
function Range01(i,v) {
  return (v - i.lo ) / (i.hi - i.lo + 1e-32)
}
function Range1(i,v) {
	v += 0
	if (v < i.lo) i.lo = v
	if (v > i.hi) i.hi = v
	return v
}
function Table(i,name) {
	i.file   = name
  i.sep    = ","
  i.ignore = "-"
  i.klassc = "/"; has(i, "klass")
  i.numc   = ":"; has(i, "num")
  i.morec  = ">"; has(i, "more")
  i.lessc  = "<"; has(i, "less")
	has(i,  "weight")
  has(i,  "range")
	has(i,  "rows")
	has(i,  "header")
	has(i,  "backer")
	has(i,  "rw")
}
function csv2Table(i,    str,cells) {
	while((getline str < i.file ) > 0) {
    gsub(/[ \t\r]*/,"",str) # no whitespce:
    gsub(/#.*$/,"",str)     # no comments
    if (str)  {             # if anything left
      split(str,cells,i.sep)
		  if (length(i.header))
				TableRow(i,cells) 
			else
				TableHeader(i,cells)
	}}
  close(i.file)
}
function TableHeader(i,headers,    head,all,r,w) {
	all=length(headers)
  for(r=1; r<=all; r++) {
    head = headers[r]
    if (head ~ i.ignore)  
      continue
    i.rw[ ++w ] = r
    i.header[w] = head
    i.backer[ head ] = w
    if (head ~ i.klassc)     i.klass[w]
		else if (head ~ i.morec) i.more[w] 
		else if (head ~ i.lessc) i.less[w] 
		else if (head ~ i.numc)  i.num[w]
		# ---------------------------------------------
		if (w in i.more) i.weight[w] =  1
	  if (w in i.less) i.weight[w] = -1
		if (w in i.more) have(i.range, w, "Range")
    if (w in i.less) have(i.range, w, "Range") 
    if (w in i.num)  have(i.range, w, "Range")
}}
function TableRow(i,values,    j,w,value) {
	j = length(i.rows) + 1
	have(i.rows, j, "Row")
  for(w in i.rw) {
    value = values[ i.rw[w] ]
	  if(w in i.range) 
			value = Range1(i.range[w], value)
    i.rows[j].raw[w] = value
}}
function TableCdom(i,r1,r2, 
                 n,w,x,y,sum1,sum2,e) {
  e = 2.71828
	n = length(i.weight)
	for(w in i.weight) {
		   x  = Range01(i.range[w], i.rows[r1].raw[w])
		   y  = Range01(i.range[w], i.rows[r2].raw[w])
		sum1 -= e ^ ( i.weight[w] * (x - y)/n )
		sum2 -= e ^ ( i.weight[w] * (y - x)/n )
	}
	return sum1/n < sum2/n
} 
function cmp_cdoms(a,b,c,d) {
	return b.cdoms + 0 < d.cdoms + 0
}
function TableSort(i,   sum,r1,r2,tmp,a) {
	for(r1 in i.rows)  
		for(r2 in i.rows) 
		  if (r1 > r2)  
			  if (TableCdom(i,r1,r2))  
				  i.rows[r1].cdoms++
  asort(i.rows,i.rows,"cmp_cdoms")
}
function Node(i) { 
  i.use=   0 # set to 1 if Node passes sanity checks
  has(i,  "left")
  has(i,  "right")
  has(i,  "all")
	have(i, "x", "Num")
	have(i, "y", "Num")
}
function Num(i) { 
  i.n  = i.mu = i.m2 = i.sd = 0 
  i.lo =  1e32
  i.hi = -1e32
}
function Num1(i,v,          delta) {
  v = v+0
  if (v < i.lo) i.lo = v
  if (v > i.hi) i.hi = v
  i.n  += 1
  i.all[i.n] = v
  delta = v - i.mu
  i.mu += delta/i.n
  i.m2 += delta*(v-i.mu)
  if (i.n > 1)
	  i.sd = (i.m2/(i.n-1))^0.5
  return v
}
function Nodes(i,  lvl, q){
  q=", "
  print(lvl "[" i.num.lo q i.num.hi q i.num.n q i.num.sd "]")
  if (i.left.use)
    Nodes(i.left,lvl "|  ")
  if (i.right.use)
    Nodes(i.right,lvl "|  ")
}
function Div(i) {
  i.cohen  = 0.2
  i.size   = 0.5
  i.min    = 20
  i.epsilon= 0
  have(i,"root","Node")
}
function Div1(i,lst1,    lst2,j,n) {
  n=asort(lst1,lst2)
  for(j=1;j<=n;j++)
    Node1(i.root, lst2[j])
  i.epsilon = i.root.sd*i.cohen
  i.min     = length(lst2)**i.size
  DivRecurse(i, i.root)
}
function DivRecurse(i, t,     j) {
  if (t.n < 2*i.min)        
    return 
  if (t.all[t.n] - t.all[1] < i.epsilon) 
    return 
  t.use = 1
  Node(t.left)
  Node(t.right) 
  while(j < t.n/2)
    Node1(t.left,  t.all[++j])
  while(j < t.n)
    Node1(t.right, t.all[++j])
  if (t.right.mu - t.left.mu >= i.epsilon)  
    if (xpectedSd(t.right, t.left) < t.sd)  {
      DivRecurse(i, t.left)
      DivRecurse(i, t.right)
}}
function xpectedSd(i,j,    n) {
  n = i.n + j.n
  return i.n/n*i.sd + j.n/n*j.sd
}


